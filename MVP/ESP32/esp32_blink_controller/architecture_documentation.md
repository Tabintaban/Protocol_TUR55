# Архитектура ESP32 Blink Controller

## Содержание
1. [Архитектура ESP32 скетча](#архитектура-esp32-скетча)
2. [Архитектура Web интерфейса для телефона](#архитектура-web-интерфейса-для-телефона)
3. [Реализация функционала проверки наличия config.json](#реализация-функционала-проверки-наличия-configjson)
4. [Реализация функционала запуска/останова мигания](#реализация-функционала-запускаостанова-мигания)
5. [Реализация таймера 3 минуты с отображением сообщения](#реализация-таймера-3-минуты-с-отображением-сообщения)
6. [Интеграция ESP32 скетча с Web интерфейсом через WiFi](#интеграция-esp32-скетча-с-web-интерфейсом-через-wifi)
7. [Тестирование и отладка системы](#тестирование-и-отладка-системы)

## Архитектура ESP32 скетча

### Основные компоненты

#### Структура данных для последовательности миганий
```cpp
struct BlinkStep {
  int lowDuration;   // Длительность LOW сигнала в миллисекундах
  int highDuration;  // Длительность HIGH сигнала в миллисекундах
};
```

#### Основные переменные
- `BlinkStep* sequence` - массив структур с параметрами миганий
- `int sequenceLength` - количество шагов в последовательности
- `int totalDuration` - общая продолжительность работы в секундах
- `bool isRunning` - флаг состояния работы (старт/стоп)
- `unsigned long startTime` - время начала работы
- `int currentStep` - текущий шаг в последовательности
- `unsigned long stepStartTime` - время начала текущего шага
- `bool stepState` - текущее состояние (LOW/HIGH)
- `int ledPin` - пин светодиода (обычно GPIO2 для встроенного светодиода ESP32)

#### Функции

##### setup()
- Инициализация Serial порта
- Инициализация SPIFFS для чтения config.json
- Загрузка параметров из config.json
- Настройка WiFi в режиме точки доступа (AP) или клиента
- Установка пина светодиода как выход

##### loop()
- Проверка состояния таймера (3 минуты)
- Выполнение последовательности миганий
- Обработка команд из Web интерфейса

##### loadConfigFromJSON()
- Открытие файла config.json из SPIFFS
- Парсинг JSON данных
- Заполнение массива последовательности миганий
- Извлечение параметра duration

##### startBlinking()
- Установка флага isRunning в true
- Сохранение времени начала
- Сброс текущего шага

##### stopBlinking()
- Установка флага isRunning в false
- Установка светодиода в LOW состояние

##### handleBlinkSequence()
- Логика переключения между HIGH/LOW состояниями
- Переход к следующему шагу последовательности
- Циклическое выполнение последовательности до истечения времени

##### checkTimer()
- Проверка, истекло ли время работы (3 минуты)
- Остановка мигания при истечении времени
- Установка флага "время истекло"

##### handleRoot()
- Обработка запроса главной страницы
- Отправка HTML файла из SPIFFS (/index.html)

##### handleCSS()
- Обработка запросов CSS файлов
- Отправка CSS файла из SPIFFS (/style.css)

##### handleJS()
- Обработка запросов JavaScript файлов
- Отправка JS файла из SPIFFS (/script.js)

##### handleWiFiRequests()
- Обработка HTTP запросов от Web интерфейса
- Обработка команд "старт", "стоп", "проверка состояния"

### Архитектурные особенности

#### WiFi режим
ESP32 будет работать в режиме точки доступа (AP), к которой можно будет подключиться с телефона. Это обеспечит автономную работу без зависимости от внешней сети.

#### Файловая система
- Используется SPIFFS для хранения и чтения файлов веб-интерфейса и config.json
- Папка data содержит:
  - index.html - основная HTML страница веб-интерфейса
  - style.css - CSS стили веб-интерфейса
  - script.js - JavaScript код веб-интерфейса
  - config.json - конфигурационный файл с параметрами мигания

#### Таймер
- Используется millis() для отслеживания времени (не блокирующая реализация)
- При истечении 3 минут мигание останавливается и устанавливается флаг состояния

#### Web интерфейс взаимодействие
- Реализован через веб-сервер на ESP32
- Поддержка HTTP GET запросов для получения состояния
- Поддержка HTTP POST запросов для управления (старт/стоп)

## Архитектура Web интерфейса для телефона

### Основные компоненты интерфейса

#### Структура HTML страницы
- Простой, адаптивный дизайн для мобильных устройств
- Одна основная страница с элементами управления
- Использование CSS Grid или Flexbox для адаптивности

#### Основные элементы интерфейса
- Кнопка "Проверить состояние" - проверяет наличие и доступность config.json на ESP32
- Кнопка "Старт/Стоп" - управляет началом и остановкой мигания
- Индикатор состояния - показывает текущий статус (готов к работе/работает/время истекло)
- Таймер обратного отсчета - отображает оставшееся время до окончания работы (3 минуты)
- Сообщение "Время жизни истекло" - отображается после окончания 3-минутного периода

#### Функции JavaScript

##### checkESP32Status()
- Отправляет GET запрос на ESP32 для проверки наличия config.json
- Обновляет индикатор состояния
- Возвращает информацию о наличии и валидности конфигурационного файла

##### startStopBlinking()
- Отправляет POST запрос на ESP32 для запуска/останова мигания
- Изменяет текст кнопки "Старт/Стоп" в зависимости от текущего состояния
- Обновляет индикатор состояния

##### updateCountdownTimer()
- Отслеживает оставшееся время до окончания 3-минутного периода
- Обновляет отображение таймера каждую секунду
- Показывает сообщение "Время жизни истекло" при окончании периода

##### updateUIState()
- Обновляет все элементы интерфейса в соответствии с текущим состоянием системы
- Отображает актуальную информацию о состоянии ESP32

### Состояния интерфейса
- "Готов к работе" - config.json доступен, система готова к запуску
- "Работает" - мигание активно, таймер отсчитывает оставшееся время
- "Время истекло" - 3-минутный период завершен, мигание остановлено

### Обработка ошибок
- Проверка доступности ESP32
- Обработка сетевых ошибок
- Индикация ошибок пользователю

### AJAX запросы
- Все взаимодействия с ESP32 осуществляются через асинхронные HTTP запросы
- Использование fetch API для взаимодействия с веб-сервером ESP32
- Обработка ответов и обновление интерфейса без перезагрузки страницы

### Автоматическое обновление состояния
- Интерфейс может периодически опрашивать ESP32 для получения актуального состояния
- Интервал обновления: 1-2 секунды для проверки состояния
- При активной работе (мигание) интервал может быть меньше для точного отображения таймера

### Технологии
- HTML5 для структуры страницы
- CSS3 для стилизации и адаптивности
- JavaScript (ES6+) для интерактивности
- AJAX для взаимодействия с ESP32
- Адаптивный дизайн для мобильных устройств

## Реализация функционала проверки наличия config.json

### Описание функционала

Функционал проверки наличия config.json включает в себя:

1. На стороне ESP32:
   - Проверка наличия файла config.json в SPIFFS
   - Валидация структуры JSON файла
   - Обработка HTTP запроса от веб-интерфейса для проверки состояния
   - Отправка ответа о наличии/отсутствии и валидности файла

2. На стороне веб-интерфейса:
   - Отправка запроса на ESP32 для проверки наличия config.json
   - Обработка ответа и обновление UI
   - Отображение статуса готовности системы

### Реализация на ESP32

#### HTTP endpoint для проверки
- URL: `/api/check-config`
- Метод: GET
- Ответ: JSON объект с информацией о наличии и валидности файла

#### Структура ответа
```json
{
  "configExists": true/false,
  "isValid": true/false,
  "sequenceLength": число элементов в последовательности,
  "totalDuration": общая длительность в секундах,
  "error": "опциональное сообщение об ошибке"
}
```

#### Алгоритм проверки
1. Попытка открытия файла config.json из SPIFFS
2. Если файл не найден - возврат `configExists: false`
3. Если файл найден - попытка парсинга JSON
4. Если JSON невалиден - возврат `isValid: false`
5. Если JSON валиден - извлечение параметров и возврат `isValid: true`
6. Отправка JSON ответа клиенту

### Реализация во веб-интерфейсе

#### Функция checkConfigStatus()
- Отправляет GET запрос на `/api/check-config`
- Обрабатывает ответ и обновляет состояние UI
- Показывает статус: "Конфигурация найдена и валидна" / "Конфигурация отсутствует" / "Конфигурация невалидна"

#### Обновление интерфейса
- Изменение текста индикатора состояния
- Блокировка/разблокировка кнопки "Старт" в зависимости от наличия валидного config.json
- Отображение дополнительной информации о конфигурации (длительность, количество шагов)

### Обработка ошибок
- Сетевые ошибки (ESP32 недоступен)
- Формат ответа не соответствует ожидаемому
- Таймаут запроса
- Повторные попытки запроса при ошибках

### Интеграция с основной системой
- Кнопка "Проверить состояние" в веб-интерфейсе вызывает функцию проверки
- Периодическая автоматическая проверка (например, раз в 5 секунд)
- Обновление статуса в реальном времени

## Реализация функционала запуска/останова мигания

### Описание функционала

Функционал запуска/останова мигания включает в себя:

1. На стороне ESP32:
   - Прием команды запуска/останова от веб-интерфейса
   - Управление состоянием мигания (активно/неактивно)
   - Обработка HTTP POST запроса для управления миганием
   - Возврат текущего состояния системы

2. На стороне веб-интерфейса:
   - Отправка команды запуска/останова на ESP32
   - Обработка ответа и обновление UI
   - Изменение текста кнопки в зависимости от текущего состояния

### Реализация на ESP32

#### HTTP endpoint для управления
- URL: `/api/control`
- Метод: POST
- Тело запроса: JSON объект с командой
```json
{
  "command": "start" или "stop"
}
```

#### Структура ответа
```json
{
  "success": true/false,
  "currentStatus": "idle" или "running" или "expired",
  "message": "опциональное сообщение"
}
```

#### Алгоритм обработки команды
1. Парсинг тела запроса для получения команды
2. Валидация команды (должна быть "start" или "stop")
3. Если команда "start":
   - Проверка, что config.json существует и валиден
   - Проверка, что таймер еще не истек
   - Установка флага isRunning в true
   - Сохранение времени начала
   - Сброс текущего шага последовательности
4. Если команда "stop":
   - Установка флага isRunning в false
   - Установка светодиода в LOW состояние
5. Отправка JSON ответа клиенту

#### Управление миганием
- В основном цикле (loop()) проверяется флаг isRunning
- Если isRunning = true, выполняется последовательность миганий
- Переключение между LOW и HIGH состояниями в соответствии с config.json
- После завершения одного шага переходим к следующему
- По окончании последовательности начинаем сначала до истечения времени

### Реализация во веб-интерфейсе

#### Функция toggleBlinking()
- Отправляет POST запрос на `/api/control` с командой
- Обрабатывает ответ и обновляет состояние UI
- Изменяет текст кнопки "Старт" → "Стоп" или "Стоп" → "Старт"
- Обновляет индикатор состояния

#### Обновление интерфейса
- Изменение текста кнопки "Старт/Стоп" в зависимости от текущего состояния
- Обновление индикатора статуса (работает/не работает)
- Блокировка кнопки при истечении времени

### Обработка ошибок
- Сетевые ошибки (ESP32 недоступен)
- Неверный формат команды
- Команда запуска при истекшем времени
- Таймаут запроса
- Повторные попытки запроса при ошибках

### Состояния системы
- "idle" - система готова, но мигание не активно
- "running" - мигание активно
- "expired" - время 3 минут истекло, мигание невозможно

### Интеграция с таймером
- При запуске мигания также запускается 3-минутный таймер
- При остановке мигания таймер не сбрасывается
- При истечении таймера автоматически останавливается мигание

## Реализация таймера 3 минуты с отображением сообщения

### Описание функционала

Функционал таймера включает в себя:

1. На стороне ESP32:
   - Отсчет 3-минутного периода при запуске мигания
   - Проверка истечения времени в основном цикле
   - Остановка мигания при истечении времени
   - Управление состоянием "время истекло"
   - Отправка состояния таймера веб-интерфейсу

2. На стороне веб-интерфейса:
   - Отображение оставшегося времени
   - Показ сообщения "Время жизни истекло" при окончании периода
   - Блокировка управления после истечения времени

### Реализация на ESP32

#### Переменные таймера
- `unsigned long startTime` - время начала отсчета (в миллисекундах)
- `int totalDuration` - общая длительность в секундах (180 для 3 минут)
- `bool timerExpired` - флаг истечения времени
- `bool timerStarted` - флаг начала отсчета

#### Алгоритм работы таймера
1. При команде "start" сохраняем текущее время в startTime
2. В основном цикле проверяем:
   - Если timerStarted и !timerExpired:
     - Вычисляем прошедшее время: (millis() - startTime) / 1000
     - Если прошедшее время >= totalDuration:
       - Устанавливаем timerExpired = true
       - Останавливаем мигание
       - Устанавливаем светодиод в LOW состояние
3. При команде "stop" таймер не сбрасывается, только останавливается мигание
4. При запросе состояния возвращаем оставшееся время

#### HTTP endpoint для получения состояния таймера
- URL: `/api/timer-status`
- Метод: GET
- Ответ: JSON объект с информацией о состоянии таймера
```json
{
  "timerExpired": true/false,
  "timeRemaining": оставшееся время в секундах,
  "timeElapsed": прошедшее время в секундах,
  "totalDuration": общая длительность в секундах
}
```

#### Интеграция с миганием
- При истечении времени автоматически останавливается мигание
- Флаг timerExpired влияет на результат команд старт/стоп
- При истечении времени кнопка "Стоп" становится недоступной

### Реализация во веб-интерфейсе

#### Функция updateTimerDisplay()
- Отправляет GET запрос на `/api/timer-status`
- Обрабатывает ответ и обновляет отображение времени
- Показывает/скрывает сообщение "Время жизни истекло"
- Обновляет интерфейс при истечении времени

#### Отображение таймера
- Показ оставшегося времени в формате MM:SS
- Автоматическое обновление каждую секунду при активной работе
- После истечения времени показывает "00:00" и сообщение "Время жизни истекло"

#### Обновление интерфейса при истечении времени
- Показ сообщения "Время жизни истекло"
- Изменение текста кнопки на "Таймер истек"
- Блокировка кнопки "Старт/Стоп"
- Изменение стиля индикатора состояния

#### Алгоритм обновления таймера
1. Если состояние "running" - запрашиваем таймер каждую секунду
2. Если таймер истек - останавливаем обновления, показываем сообщение
3. Обновляем отображение времени в формате MM:SS
4. При команде "старт" снова начинаем обновления

### Обработка ошибок
- Сетевые ошибки при запросе состояния таймера
- Несоответствие формата ответа
- Синхронизация времени между ESP32 и веб-интерфейсом
- Корректная работа при переполнении millis()

### Интеграция с другими компонентами
- Таймер влияет на возможность запуска мигания
- Состояние таймера отражается в общем состоянии системы
- При истечении таймера становится недоступным управление

## Интеграция ESP32 скетча с Web интерфейсом через WiFi

### Описание интеграции

Интеграция включает в себя создание WiFi соединения между ESP32 и телефоном, а также реализацию веб-сервера на ESP32 для обработки запросов от веб-интерфейса.

### Режим WiFi

#### Режим точки доступа (Access Point)
- ESP32 создает собственную WiFi сеть
- Имя сети (SSID): "ESP32_Blink_Controller" (или подобное)
- Пароль: "123456789" (или другой простой пароль для демонстрации)
- IP адрес ESP32 в режиме AP: 192.168.4.1
- Телефон подключается к этой сети для управления ESP32

#### Альтернативный режим: Station Mode
- ESP32 подключается к существующей WiFi сети
- В этом случае телефон также должен быть подключен к той же сети
- IP адрес определяется DHCP роутера

### Веб-сервер на ESP32

#### Библиотеки
- WiFi.h - для управления WiFi соединением
- WebServer.h - для создания HTTP сервера
- SPIFFS.h - для работы с файловой системой
- ArduinoJson.h - для парсинга JSON

#### HTTP endpoints
1. `/` - главная страница веб-интерфейса (index.html)
2. `/style.css` - CSS стили веб-интерфейса
3. `/script.js` - JavaScript код веб-интерфейса
4. `/api/check-config` - проверка наличия config.json
5. `/api/control` - управление миганием (старт/стоп)
6. `/api/timer-status` - получение состояния таймера

#### Обработка подключений
- Ограничение количества одновременных подключений
- Обработка HTTP заголовков
- Управление сессиями при необходимости

### Веб-интерфейс

#### Размещение файлов
- HTML, CSS и JavaScript файлы размещаются в SPIFFS в папке data
- Главная страница: /index.html
- Стили: /style.css
- Скрипты: /script.js

#### Загрузка интерфейса
- При подключении к ESP32 открываем браузер и переходим на http://192.168.4.1
- Веб-сервер отдает главную страницу интерфейса из файла index.html
- CSS стили подгружаются из файла style.css
- JavaScript код подгружается из файла script.js
- JavaScript на странице начинает взаимодействие с API endpoints

### Безопасность

#### Аутентификация (опционально)
- Простая HTTP аутентификация при необходимости
- Ограничение доступа к управляющим функциям

#### Защита от частых запросов
- Ограничение частоты запросов от клиента
- Предотвращение перегрузки ESP32

### Обработка ошибок соединения

#### На стороне ESP32
- Обработка прерванных соединений
- Очистка ресурсов при разрыве соединения
- Логирование ошибок соединения

#### На стороне веб-интерфейса
- Проверка доступности ESP32 перед запросами
- Обработка таймаутов соединения
- Индикация состояния подключения

### Оптимизация производительности

#### Экономия ресурсов ESP32
- Использование асинхронных методов где возможно
- Минимизация объема передаваемых данных
- Эффективное управление памятью при обработке JSON

#### Оптимизация взаимодействия
- Кэширование статических файлов интерфейса
- Минимизация количества HTTP запросов
- Использование WebSocket при необходимости (для более сложных сценариев)

### Сценарии использования

#### Стандартный сценарий
1. ESP32 запускается и создает WiFi точку доступа
2. Пользователь подключается с телефона к точке доступа ESP32
3. Открывается веб-интерфейс по адресу http://192.168.4.1
4. Пользователь проверяет наличие config.json
5. При наличии валидного конфига пользователь запускает мигание
6. Веб-интерфейс отображает таймер и состояние мигания
7. После 3 минут работы система автоматически останавливается

#### Аварийные сценарии
1. Потеря соединения во время работы
2. Недоступность ESP32
3. Ошибка в конфигурационном файле
4. Истечение времени работы

## Тестирование и отладка системы

### План тестирования

#### Модульное тестирование
1. Тестирование чтения config.json из SPIFFS
   - Проверка наличия файла
   - Проверка валидности JSON структуры
   - Проверка корректности извлеченных параметров

2. Тестирование функций мигания
   - Проверка переключения состояний LOW/HIGH
   - Проверка длительности импульсов по config.json
   - Проверка последовательности миганий

3. Тестирование таймера
   - Проверка отсчета 3-минутного периода
   - Проверка остановки мигания по истечении времени
   - Проверка установки состояния "время истекло"

4. Тестирование WiFi соединения
   - Проверка создания точки доступа
   - Проверка подключения клиента
   - Проверка стабильности соединения

5. Тестирование веб-сервера
   - Проверка обработки HTTP запросов
   - Проверка корректности API endpoints
   - Проверка форматов запросов и ответов

#### Интеграционное тестирование
1. Полный цикл работы системы
   - Подключение к WiFi точке ESP32
   - Проверка конфигурации через веб-интерфейс
   - Запуск мигания
   - Остановка мигания
   - Истечение времени и автоматическая остановка

2. Тестирование сценариев ошибок
   - Отсутствие config.json
   - Невалидный формат config.json
   - Потеря соединения во время работы
   - Попытка запуска после истечения времени

#### Тестирование пользовательского интерфейса
1. Проверка отображения состояний
2. Проверка корректности таймера на интерфейсе
3. Проверка реакции на команды пользователя
4. Проверка отображения сообщений

### Отладка

#### Логирование на ESP32
- Вывод информации в Serial Monitor
- Логирование состояний системы
- Логирование HTTP запросов и ответов
- Логирование ошибок и исключительных ситуаций

#### Инструменты отладки
1. Serial Monitor
   - Для просмотра логов ESP32
   - Для отладки состояний и ошибок

2. Браузерные инструменты разработчика
   - Для отладки JavaScript веб-интерфейса
   - Для проверки HTTP запросов и ответов

3. Network анализаторы
   - Для анализа WiFi трафика при необходимости

### Проверочные сценарии

#### Сценарий 1: Нормальный цикл работы
1. Загрузка скетча на ESP32
2. Загрузка config.json в SPIFFS
3. Запуск ESP32
4. Подключение телефона к WiFi точке ESP32
5. Открытие веб-интерфейса
6. Проверка наличия config.json
7. Запуск мигания
8. Наблюдение за миганием в течение 3 минут
9. Автоматическая остановка по истечении времени

#### Сценарий 2: Ручная остановка
1. Выполнить шаги 1-7 из сценария 1
2. Остановка мигания через веб-интерфейс до истечения времени
3. Проверка корректной остановки

#### Сценарий 3: Ошибка конфигурации
1. Убедиться, что config.json отсутствует или невалиден
2. Открытие веб-интерфейса
3. Проверка корректного отображения ошибки

#### Сценарий 4: Повторный запуск после истечения времени
1. Выполнить сценарий 1 до автоматической остановки
2. Попытка запуска мигания после истечения времени
3. Проверка блокировки запуска и отображения соответствующего сообщения

### Критерии успешного тестирования

#### Функциональные критерии
- ESP32 успешно создает WiFi точку доступа
- Веб-интерфейс корректно загружается и отображается
- Проверка config.json работает корректно
- Мигание происходит в соответствии с параметрами из config.json
- Таймер точно отсчитывает 3 минуты
- Мигание автоматически останавливается по истечении времени
- Сообщение "Время жизни истекло" отображается корректно
- Управление через веб-интерфейс работает без задержек

#### Нефункциональные критерии
- Система стабильно работает в течение всего 3-минутного периода
- Ответы на HTTP запросы возвращаются за приемлемое время
- Потребление памяти остается в допустимых пределах
- WiFi соединение стабильно в течение сессии

### Возможные проблемы и решения

#### Проблемы с WiFi
- Проблема: ESP32 не создает точку доступа
- Решение: Проверить настройки WiFi, обновить драйверы

#### Проблемы с SPIFFS
- Проблема: config.json не читается из SPIFFS
- Решение: Проверить процесс загрузки файла в SPIFFS

#### Проблемы с таймером
- Проблема: Неточное отсчет времени
- Решение: Проверить использование millis() и возможное переполнение

#### Проблемы с миганием
- Проблема: Неправильная последовательность или длительность
- Решение: Проверить алгоритм обработки config.json